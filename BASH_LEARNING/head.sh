#!/bin/bash
# rnd.sh: 10 자리 랜덤한 숫자 출력

# Script by Stephane Chazelas.

head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'


# =================================================================== #

# 분석
# ----

# head:
# -c4 옵션은 첫 번째 4 바이트만 받아 들입니다.

# od:
# -N4 옵션은 출력을 4 바이트로 제한해 줍니다.
# -tu4 옵션은 출력을 unsigned 10진 포맷으로 해줍니다.

#  sed: 
#  -n 옵션은 "s" 명령어의 "p" 플래그와 같이 쓰여서 
#+ 오직 일치하는 줄만 출력해 줍니다.



# 다음은 이 스크립트의 저자가 'sed'의 동작에 대해서 설명한 내용입니다.

# head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
# ----------------------------------> |

# "sed"로 들어가는 출력을   --------> |
# 0000000 1198195154\n 라고 가정하면

# sed가 0000000 1198195154\n 을 읽으면,
# 뉴라인(\n) 문자를 발견하기 때문에 첫 번째 줄(0000000 1198195154)에 
# 대해서 처리할 준비가 됩니다.
# 그 다음에는 자신의 <주소 범위><동작> 을 참고하는데 여기서는

#   주소 범위  동작
#   1          s/.* //p

# 가 됩니다.

# 줄 번호가 주소 범위안에 들어가기 때문에 동작을 수행합니다:
# 그 줄에서 공백문자로 끝나는 가장 긴 문자열("0000000 ")을 
# 아무것도 아닌 것으로(//) 치환시키고, 성공한다면 그 결과를 출력해 줍니다
# (여기에서, "p"는 "s" 명령어에 대한 플래그지 "p" 명령어가 아닙니다).

# sed 는 이제 다음 입력을 받을 준비를 합니다(여기서 주의할 점은,
# 만약에 -n 옵션이 없다면, 그 줄을 한 번 더 출력할 것이라는 것입니다).

# 그 다음에는 나머지 문자들을 읽어 들이는데, 파일의 끝을 발견하게 됩니다.
# 이제 마지막 줄임을 나타내는 '$'가 매겨지는 두 번째 줄을 처리할 준비가 된거죠.
# 그런데 두 번째 줄은 어떤 <범위> 에도 들지 않기 때문에 동작을 멈춥니다.

# 이 동작들을 간단하게 설명해 보면 다음과 같습니다:
# "첫번째 줄만 읽은 다음 제일 오른쪽에 나오는 빈 칸까지 삭제한 다음 출력"

# 이렇게 하면 더 좋을 수도 있습니다:
#           sed -e 's/.* //;q'

# 두 개의 <주소 범위><동작> 으로 쓰일 수도 있습니다.
#           sed -e 's/.* //' -e q):

#   주소 범위                동작
#   일치하는 줄 없음         s/.* //
#   일치하는 줄 없음         q (quit)

# 이렇게 하면, sed 는 오직 첫 번째 줄만 입력으로 받아 들입니다.
# "-n" 옵션이 없기 때문에 종료하기("q" 명령어) 전에 바뀐 줄을 출력해 줍니다.

# =================================================================== #

# 위의 한 줄짜리 스크립트는 더 간단하게 쓸 수도 있습니다:
#           head -c4 /dev/urandom| od -An -tu4

exit 0
